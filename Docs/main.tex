\documentclass{article}

\input{structure.tex}
\usepackage{lineno}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{epigraph} 
\modulolinenumbers[5]
\usepackage{caption}
\usepackage{subcaption}

\usetikzlibrary{positioning}
\usetikzlibrary{dsp,chains}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\newcommand{\z}{\mathpzc{z}}

\crefname{equation}{εξ.}{εξ.}
\crefname{listing}{καταχώριση}{καταχώριση}

\makeindex

\bibliographystyle{ieeetr}

\newcommand{\filterspectrums}[2]
{
\begin{figure}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{#1.png}
         \caption{Φασματογράφημα του αρχείου.}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[width=\textwidth]{#1_spectrum.png}
         \caption{Το φάσμα (πράσινο).}
     \end{subfigure}
     \hfill
        \caption{#2}
        % \label{fig:sus}
\end{figure}
}

\begin{document}

\begin{titlepage}

\title{Σχεδιασμός και υλοποίηση ψηφιακού ισοσταθμιστή ήχου.}

%% Group authors per affiliation:
\author{Ευάγγελος Λάμπρου}
\date{}

\maketitle


\begin{abstract}
    Στα πλαίσια αυτής της εργασίας γίνεται ο σχεδιασμός και υλοποίηση 
    ενός ισοσταθμιστή ήχου. 
    Η ανάπτυξή του συστήματος ψηφιακής επεξεργασίας σήματος, όπως 
    και η γραφική διεπαφή έγιναν μέσα στο περιβάλλον του 
    \en{JUCE Framework} χρησιμοποιώντας τη γλώσσα \en{C++}. 
    Στην εργασία αυτή γίνεται η ανάλυση της θεωρίας πίσω από την ανάπτυξη των φίλτρων, 
    την υλοποίηση του συστήματος από το χαμηλό έως το υψηλό επίπεδο αφαιρετικότητας που 
    προσφέρει το πακέτο \en{JUCE}. 
    Τέλος, υπάρχει ανάλυση των επιδόσεων του φίλτρου όπως και μία σύντομη αναφορά πάνω 
    στην ευκολία χρήσης του.
\end{abstract}

% \tableofcontents

\end{titlepage}

\linenumbers

\section{Σχεδιασμός}

\begin{figure}[htpb]

    \begin{center}

        \begin{tikzpicture}

        % Controller

        \node [draw,
        fill=Goldenrod,
        minimum width=2cm,
        minimum height=1.2cm,
        right=1cm
            ] (dsp) {$DSP$};

        \draw[->] ++(-1,0) -- (dsp.west) 
            node[midway,above]{$audio_{in}$};

        \draw[->] ++(-1,0) -- (dsp.west) 
            node[midway,above]{$audio_{in}$};

        \draw[->] (dsp.east) --  ++(+2,0) 
            node[midway,above]{$audio_{out}$};
        \end{tikzpicture}
    \end{center}

    \caption{Βασική δομή του \en{plugin}.} 
\end{figure}

\subsection{Θεωρία \en{IIR} φίλτρων}

Στην εργασία αυτή θα περιοριστούμε στην υλοποίηση φίλτρων 2ης τάξης, με τους 
αλγόριθμους όμως να είναι ικανούς να παράγουν φίλτρα οσοδήποτε μεγάλης τάξης (χωρίς 
βέβαια να εγγυάται η ορθότητα του τελικού αποτελέσματος λόγω πεπαρασμένης ακρίβειας 
στις τιμές των συντελεστών). 

Έχοντας ως βάση ένα χαμηλοπερατό φίλτρο 2ης τάξης \cite{OpenheimAlan}

\begin{equation}
    H(s) = \frac{1}{s^2 + s/Q + 1} 
    \label{eq:h_lowpassfilter}
\end{equation}

Μέσω του διπολικού $Z$ μετασχηματισμού, θέτωντας $s = \frac{1}{K}\frac{z-1}{z+1} \; K = \frac{1}{2F_s}$ έχουμε \cite{BilinearZTransformWeb}

\begin{equation}
    H(z) = \frac{K^2 + 2K^2 z^{-1} + K^2 z^{-2}}{(K^2 + K/Q + 1) + 2(K^2 - 1) z^{-1} + (K^2 - K/Q + 1) z^{-2}}
    \label{eq:h_z_final}
\end{equation}


\paragraph{Φίλτρα \en{Butteworth}} 

Επιλέξαμε το φίλτρο \en{Butterworth} σχεδόν αυθαίρετα. Ωστόσο, το φίλτρο 
έχει ορσιμένες ιδιότητες που το κάνουν θεμιτό στα πλαίσια επεξεργασίας ήχου.
Αρχικά, τα φίλτρα αυτά δεν έχουν \en{ripple} κοντά στη συχνότητα αποκοπής 
και έτσι δεν υπάρχει ενίσχυση καμίας συχνότητας. Ακόμα, 
έχουν πιο αργή αποκοπή ($-6n db/οκτάβα$, όπου $n$ η τάξη του φίλτρου). 
Αυτό σε εφαρμογές ήχου είναι πολλές φορές θεμιτό μιας και δίνει σαν αποτέλεσμα ένα πιο μαλακό 
κόψιμο των συχνοτήτων. Συνύθως δεν θέλουμε να διώξουμε ολοκληρωτικά τις αρμονικές 
από κάποιο όργανο.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\textwidth]{./assets/comparison_filters.png}
    \caption{Σύγκριση φίλτρου \en{Butterworth} με άλλα φίλτρα.}
    \label{fig:}
\end{figure}

Για τους συντελεστές του φίλτρου \en{Butterworth} μπορούμε απλά να υπολογίσουμε την τιμή 
της σταθεράς $Q$ και να πάρουμε τους συντελεστές από την \cref{eq:h_lowpassfilter} \cite{OpenheimAlan, JuceDocumentation}

\begin{align}
    1/Q &= {2cos(\frac{2i + 1}{n}\pi)}, \; i = 0..\frac{n}{2} \qquad n = {\text{άρτιο}} \\ 
    1/Q &= {2cos(\frac{i + 1}{2n}\pi)}, \; i = 0..\frac{n}{2} \qquad n = {\text{περιττό}}
\end{align}

\paragraph{Αλγόριθμος Υπολογισμού Συντελεστών}

Από την προηγούμενη μαθηματική ανάλυση, ο υπολογισμός των συντελεστών για το εκάστοτε φίλτρο είναι πλέον 
τετριμένος. 

Αντικαθιστώντας τις τιμές για το $Q$ για ένα φίτλρο \en{Butteworth} στη σχέση \ref{eq:h_z_final}
έχουμε πλέον τους συντελεστές του φίλτρου. 


\begin{align}
    a_0 &= \frac{K^2}{K^2 + K/Q +1} & a_1 &= 2a_0 & a_2 &= a_0 \\
    b_0 &= 1 & b_1 &= \frac{2(K^2 - 1)}{K^2 + K/Q + 1} & b_2 &= \frac{K^2 - K/Q + 1}{K^2 + K/Q + 1}
\end{align}

Ένα φίλτρο \en{Butteworth} 1ης τάξης έχει αποκοπή $-6dB/octave$, 2ης τάξης έχει αποκοπή $-12dB/octave$, ένα 3ης τάξης $-18dB/octave$ κοκ.

\section{Υλοποίηση}

Για την υλοποίηση του φίλτρου χρησιμοποιήθηκαν οι βιβλιοθήκες του πακέτου 
\en{Juce}. Το πακέτο αυτό χωρίζεται σε ενότητες \en{(modules)}, από τις οποίες
χρησιμοποιούμε κατά βάση την ενότητα \src{juce::dsp}. 
Εδώ, περιλαμβάνονται κλάσεις μέσω την οποίων μπορεί να γίνει η δημιουργία 
ενός φίλτρου.

Ο τρόπος με τον οποίο η εφαρμογή μας επεξεργάζεται τα εισερχόμενα δείγματα
\en{(samples)} είναι στη ρουτίνα \src{processBlock} όπου δεχόμαστε σαν είσοδο έναν
\en{buffer} από δείγματα στα οποία μπορούσαμε να εφαρφμόσουμε οποιονδήποτε αλγόριθμο. 

Το \en{plugin} στην πραγματικότητα αποτελείται από τρία (3) φίλτρα: 

\begin{enumerate}
    \item Ένα χαμηλοπερατό φίλτρο \en{(low pass filter)}
    \item Ένα φίλτρο κορυφής
    \item Ένα υψηπερατό φίλτρο
\end{enumerate}

\begin{figure}[htpb]

    \begin{center}

        \begin{tikzpicture}[node distance=3.0cm]

        % Controller

        \node [draw,
        fill=Purple,
        minimum width=1cm,
        minimum height=1.1cm,
            ] (lp) {$LP Filter$};

        \node [draw,
        fill=White,
        minimum width=1cm,
        minimum height=1.1cm,
        left of = lp
            ] (in) {$Source$};

        \node [draw,
        fill=Purple,
        minimum width=1cm,
        minimum height=1.1cm,
            ] (lp) {$LP Filter$};

        \node [draw,
        fill=Yellow,
        minimum width=1cm,
        minimum height=1.1cm,
            right of = lp] (pf) {$Peak Filter$};

        \node [draw,
        fill=Green,
        minimum width=1cm,
        minimum height=1.1cm,
            right of = pf] (hp) {$HP Filter$};

        \node [draw,
        fill=White,
        minimum width=1cm,
        minimum height=1.1cm,
        right of = hp
            ] (out) {$Output$};

        \draw[->] (in) -- (lp) 
            node[midway,above]{$audio_{in}$};
        \draw[->] (lp) --  (pf);
        \draw[->] (pf) --  (hp);

        \draw[->] (hp) -- (out) 
            node[midway,above]{$audio_{out}$};

        \end{tikzpicture}
    \end{center}

    \caption{Βασική δομή του \en{plugin}.} 
\end{figure}

Ο τρόπος με τον οποίο αυτό περιγράφεται στον κώδικα είναι μέσω της δομής 
\src{ProcessorChain} η οποία αναπαριστά μία αλυσιδά επεξεργαστών. 
Κατά την εκτέλεση της εφαρμογής, η ακολουθία από δείγματα
περνάει από την ρουτίνα επεξεργασίας του κάθε φίλτρου διαδοχικά. \cite{JuceDocumentation}

Στην περίπτωση που θέλαμε να έχουμε φίλτρο με πιο απότομη καμπύλη αποκοπής
συχνοτήτων (\en{slope}), θα μπορούσαμε να βάλουμε σε σειρά στο
\src{ProcessorChain} περισσότερα φίλτρα σε σειρά. Έτσι, ανάλογα με την καμπύλη
που θέλαμε θα μπορούσαμε να θέτουμε σε πέρασμα (\en{passthrough}) όλα τα
επίπεδα της αλυσίδας επεξεργασίας και να ενεργοποιούσαμε τον κατάλληλο αριθμό
από φίλτρα σε σειρά ανάλογα με το πόσο \say{απότομη} θα έπρεπε να είναι η καμπύλη.

Ο υπολογισμός της νέας αριθμητικής τιμής του κάθε δείγματος γίνεται με 
τη σειρά που φαίνεται στη \cref{fig:iir_filter_block}. 
Η καθυστέρηση του σήματος εισόδου γίνεται εφόσων το \en{plugin}
αποθηκεύει την κατάστασή του, η οποία είναι ένας πίνακας με τις τιμές της εξόδου 
του στα προηγούμενα δείγματα. Στην περίπτωση ενός φίλτρου 2ης τάξης 
αρκεί να αποθηκεύουμε τις δύο προηγούμενες τιμές εξόδου του.

Η υλόποιση σε κώδικα όπως φαίνεται στην \cref{lst:iirimp} ταυτίζεται με τη σχηματική 
αναπαράσταση. Η βιβλιοθήκη \src{JUCE} έχει προνοήσει για τη χρήση τον ρουτίνων 
της με αριθμητικούς τύπους διαφορετικής ακρίβειας, εξού και η χρήση της 
λέξης-κλειδί \src{auto} \cite{CppReferenceAuto}, η οποία αναθέτει στον \en{compiler} το συμπέρασμα του τύπου 
της εκάστοτε μεταβλητής.

\vspace{5mm}

\begin{figure}
\centering
    \input{IIR.tex}
\caption{Υλοποίηση του \en{IIR} φίλτρου}
\label{fig:iir_filter_block}

\end{figure}

\begin{minipage}{\textwidth}
    \lstcode[lst:iirimp]{./assets/src/iir.cpp}{C++}{Ο υπολογισμός της νέας τιμής για το κάθε δείγμα σε \src{C++}}
\end{minipage}

Αξίζει να σημειωθεί πως στον πυρήνα του ένα οποιοδήποτε \en{plugin} επεξεργασίας 
ήχου είναι είναι ένα σύνολο από προσθέσεις, πολλαπλασιασμούς και καθυστερήσεις. 
Σε γενικές γραμμές, η υλοποίηση των περισσότερων 
αλγορίθμων δεν είναι αξιοσημείωτη, περά από πιθανές βελτιστοποιήσεις με τη χρήση παραλληλισμού. 

Σαφώς, βιβλιοθήκες όπως η \en{JUCE} φροντίζουν στην καλύτερη δυνατή υλοποίηση, 
αφού δεν υπάρχουν κατά το δυνατόν περιτές πράξεις και γίνεται προσπάθεια 
στη βελτιστοποίηση του κώδικα από τη φάση της μετάφρασης (\en{compilation}).

\paragraph{Γραφική Διεπαφή}

\epigraph{\en{The first 90 percent of the code accounts for the first 90 percent of
the development time. The remaining 10 percent of the code accounts for the
other 90 percent of the development time}}{\en{\textit{Tom Cargill, Bell Labs}}}

Η βιβλιοθήκη \en{JUCE} παρέχει τη δυνανότητα να αναπτύξει ο χρήστης 
σύνθετες γραφικές διεπαφές μέσα από τις οποίες μπορεί κάποιος να ελέγχει 
το \en{DSP} μέρος της εφαρμογής (συχνότητες αποκοπής κτλ).

Έχουμε στη διάθεση μας πολλές επιλογές όσων αφορά την εμφάνιση της εφαρμογής. 
Η παρουσίαση έχει πολλά να κάνει και με την ευχρηστεία της εφαρμογής. 
Ελπίζουμε η απλή διεπαφή να συμβάλει σε αυτό το σκοπό. 

Είναι άξιο αναφοράς πως σε γραμμές κώδικα, η γραφική διεπαφή χρειάστηκε 
περισσότερη συγγραφή σε σχέση με τον επεξεργαστή συμάτων. 
Αυτό δεν είναι βέβαια σίγουρο αν είναι πρωτέρημα ή όχι της βιβλιοθήκης.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\textwidth]{./assets/GUI.png}
    \caption{Η τελική γραφική διεπαφή του ισοσταθμιστή.}
    \label{fig:finalgui}
\end{figure}

Στην τελική εφαρμογή υπάρχουν πέντε \en{knobs}:

\begin{itemize}
    \item Δύο για τον έλεγχο του υψιπερατού και του χαμηλοπερατού φίλτρου.
    \item Τρία για την επιλογή της \en{peak} συχνότητας, του \en{gain} το οποίο θα λάβει και του πάχους της καμπύλης, αντίστοιχα.
\end{itemize}

\paragraph{Χρήση}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\textwidth]{./assets/Carla_Basic.png}
    \caption{Εφαρμογή του \src{SimpleEq plugin} στο περιβάλλον \en{Carla}.}
    \label{fig:carla_basic}
\end{figure}

Για την χρήση του \en{plugin} \src{Simple EQ} μπορεί να γίνει 
σύνδεσή του με άλλες ροές ήχου στον υπολογιστή μέσω ενός \en{audio plugin host}.
Ένα πολύ ικανό και δημοφιλές είναι το λογισμικό \en{Carla} \cite{CarlaApp}, 
μέσα από το οποίο μπορούμε να κατευθύνουμε τη ροή ήχου από μία εφαρμογή 
στον υπολογιστή μας, μέσα από κάποιο \en{plugin} και τελικά να έχουμε την έξοδο 
στα ηχεία (ή οποιαδήποτε άλλη συσκευή).

Πιο συνιθέστερη όμως θα είναι η χρήση του \en{plugin} μέσα από ένα λογισμικό 
\en{DAW (Digital Audio Workstation)}, όπου μπορούμε να φορτώσουμε δυναμικά 
το \src{Simple EQ}, να προσθέσουμε σε ένα από τα κομμάτια του \en{mixer} 
και έτσι όποιος ήχος περνάει σε εκείνο το κανάλι θα επεξεργάζεται από τον \en{plugin}. 

Η βιβιοθήκη \src{JUCE} προσφέρει συστήματα για το χτήσιμο (\en{build}) του κώδικα 
ως \en{plugin (VST3)} \cite{VSTWiki}, ή ως αυτόνομη εφαρμογή.  

\section{Μετρήσεις}

Μετά τη δημιουργία της εφαρμογής ισοστάθμισης, έγινε εισαγωγή του \en{plugin} 
\src{SimpleEQ} στο ψηφιακό περιβάλλον επεξεργασίας ήχου (\en{DAW}) \en{Ardour}, 
το οποίο λειτουργεί σαν υποδοχέας και παρέχει δυνατότητες μέτρησης της απόκρισης συχνότας και 
φάσης του φίλτρου (\cref{fig:ardour_analysis}).

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\textwidth]{./assets/PluginAnalysisArdour.png}
    \caption{Ανάλυση του \src{SimpleEQ} μέσα από το \en{Ardour}. Φαίνεται η απόκριση συχνότητας (άσπρο) και η απόκριση φάσης (κόκκινο).}
    \label{fig:ardour_analysis}
\end{figure}

Γίνεται φανερό από την απόκριση του φίλτρου πως η αποκοπή 
είναι \say{μαλακή} (\en{soft-cut}). 

\paragraph{Μετρήσεις με \en{White Noise}}
Έπειτα, εφαρμόσαμε λευκό θόρυβο και αναλύσαμε το τελικό αρχείο ήχου.

\filterspectrums{./assets/WhiteNoise}{Το σήμα λευκού θορύβου χωρίς φίλτρο.}
\filterspectrums{./assets/WhiteNoiseLP}{Το σήμα λευκού θορύβου με εφαρμογή χαμηλοπερατού φίλτρου στα $1000Hz$.}
\filterspectrums{./assets/WhiteNoiseHP}{Το σήμα λευκού θορύβου με εφαρμογή υψιπερατού φίλτρου στα $1000Hz$.}

Μία παρατήρηση είναι πως στην περίπτωση του υψιπερατού φίλτρου, οι υψηλές συχνότητες 

Για μερικές ακόμα μετρήσεις χρησιμοποιήθηκε το τραγούδι \en{Bring Me the Disco King - David Bowie} 
το οποίο περάσαμε μέσα από \src{Simple EQ}. 

Όλα τα αρχεία τα οποία μελετάμε είναι κωδικοποιημένα σε μορφή \en{WAV 16-bit} με συχνότητα δειγματοληψίας $48kHz$.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\textwidth]{./assets/session.png}
    \caption{Ανάλυση του αρχείο \src{BringMetTheDiscoKing.wav} χωρίς εφαρμογή του \en{plugin}.}
    \label{fig:sessionanalysis}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\textwidth]{./assets/session_1000_lp.png}
    \caption{Ανάλυση του αρχείο \src{BringMetTheDiscoKing.wav} με εφαρμογή χαμηλοπερατού φίλτρου στα $1000Hz$.}
    \label{fig:sessionanalysislp1000}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\textwidth]{./assets/session_1000_hp.png}
    \caption{Ανάλυση του αρχείο \src{BringMetTheDiscoKing.wav} με εφαρμογή υψιπερατού φίλτρου στα $1000Hz$.}
    \label{fig:sessionanalysishp1000}
\end{figure}


\newpage

\bibliography{bibliography}

\end{document}
